// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	context "context"

	add_onsentity "example.com/art-culture-api/domain/add_ons/entity"

	entity "example.com/art-culture-api/domain/programs/entity"

	mock "github.com/stretchr/testify/mock"

	model "example.com/art-culture-api/domain/programs/model"

	partnersentity "example.com/art-culture-api/domain/partners/entity"
)

// MockProgramRepository is an autogenerated mock type for the ProgramRepository type
type MockProgramRepository struct {
	mock.Mock
}

type MockProgramRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProgramRepository) EXPECT() *MockProgramRepository_Expecter {
	return &MockProgramRepository_Expecter{mock: &_m.Mock}
}

// ClearProgramAddOns provides a mock function with given fields: program
func (_m *MockProgramRepository) ClearProgramAddOns(program entity.Program) (entity.Program, error) {
	ret := _m.Called(program)

	if len(ret) == 0 {
		panic("no return value specified for ClearProgramAddOns")
	}

	var r0 entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.Program) (entity.Program, error)); ok {
		return rf(program)
	}
	if rf, ok := ret.Get(0).(func(entity.Program) entity.Program); ok {
		r0 = rf(program)
	} else {
		r0 = ret.Get(0).(entity.Program)
	}

	if rf, ok := ret.Get(1).(func(entity.Program) error); ok {
		r1 = rf(program)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_ClearProgramAddOns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearProgramAddOns'
type MockProgramRepository_ClearProgramAddOns_Call struct {
	*mock.Call
}

// ClearProgramAddOns is a helper method to define mock.On call
//   - program entity.Program
func (_e *MockProgramRepository_Expecter) ClearProgramAddOns(program interface{}) *MockProgramRepository_ClearProgramAddOns_Call {
	return &MockProgramRepository_ClearProgramAddOns_Call{Call: _e.mock.On("ClearProgramAddOns", program)}
}

func (_c *MockProgramRepository_ClearProgramAddOns_Call) Run(run func(program entity.Program)) *MockProgramRepository_ClearProgramAddOns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(entity.Program))
	})
	return _c
}

func (_c *MockProgramRepository_ClearProgramAddOns_Call) Return(_a0 entity.Program, _a1 error) *MockProgramRepository_ClearProgramAddOns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_ClearProgramAddOns_Call) RunAndReturn(run func(entity.Program) (entity.Program, error)) *MockProgramRepository_ClearProgramAddOns_Call {
	_c.Call.Return(run)
	return _c
}

// ClearProgramPartners provides a mock function with given fields: program
func (_m *MockProgramRepository) ClearProgramPartners(program entity.Program) (entity.Program, error) {
	ret := _m.Called(program)

	if len(ret) == 0 {
		panic("no return value specified for ClearProgramPartners")
	}

	var r0 entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.Program) (entity.Program, error)); ok {
		return rf(program)
	}
	if rf, ok := ret.Get(0).(func(entity.Program) entity.Program); ok {
		r0 = rf(program)
	} else {
		r0 = ret.Get(0).(entity.Program)
	}

	if rf, ok := ret.Get(1).(func(entity.Program) error); ok {
		r1 = rf(program)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_ClearProgramPartners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClearProgramPartners'
type MockProgramRepository_ClearProgramPartners_Call struct {
	*mock.Call
}

// ClearProgramPartners is a helper method to define mock.On call
//   - program entity.Program
func (_e *MockProgramRepository_Expecter) ClearProgramPartners(program interface{}) *MockProgramRepository_ClearProgramPartners_Call {
	return &MockProgramRepository_ClearProgramPartners_Call{Call: _e.mock.On("ClearProgramPartners", program)}
}

func (_c *MockProgramRepository_ClearProgramPartners_Call) Run(run func(program entity.Program)) *MockProgramRepository_ClearProgramPartners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(entity.Program))
	})
	return _c
}

func (_c *MockProgramRepository_ClearProgramPartners_Call) Return(_a0 entity.Program, _a1 error) *MockProgramRepository_ClearProgramPartners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_ClearProgramPartners_Call) RunAndReturn(run func(entity.Program) (entity.Program, error)) *MockProgramRepository_ClearProgramPartners_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByID provides a mock function with given fields: id
func (_m *MockProgramRepository) DeleteByID(id uint) error {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(uint) error); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockProgramRepository_DeleteByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByID'
type MockProgramRepository_DeleteByID_Call struct {
	*mock.Call
}

// DeleteByID is a helper method to define mock.On call
//   - id uint
func (_e *MockProgramRepository_Expecter) DeleteByID(id interface{}) *MockProgramRepository_DeleteByID_Call {
	return &MockProgramRepository_DeleteByID_Call{Call: _e.mock.On("DeleteByID", id)}
}

func (_c *MockProgramRepository_DeleteByID_Call) Run(run func(id uint)) *MockProgramRepository_DeleteByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint))
	})
	return _c
}

func (_c *MockProgramRepository_DeleteByID_Call) Return(_a0 error) *MockProgramRepository_DeleteByID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockProgramRepository_DeleteByID_Call) RunAndReturn(run func(uint) error) *MockProgramRepository_DeleteByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindAddOns provides a mock function with given fields: addOns
func (_m *MockProgramRepository) FindAddOns(addOns []add_onsentity.AddOn) ([]add_onsentity.AddOn, error) {
	ret := _m.Called(addOns)

	if len(ret) == 0 {
		panic("no return value specified for FindAddOns")
	}

	var r0 []add_onsentity.AddOn
	var r1 error
	if rf, ok := ret.Get(0).(func([]add_onsentity.AddOn) ([]add_onsentity.AddOn, error)); ok {
		return rf(addOns)
	}
	if rf, ok := ret.Get(0).(func([]add_onsentity.AddOn) []add_onsentity.AddOn); ok {
		r0 = rf(addOns)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]add_onsentity.AddOn)
		}
	}

	if rf, ok := ret.Get(1).(func([]add_onsentity.AddOn) error); ok {
		r1 = rf(addOns)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_FindAddOns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAddOns'
type MockProgramRepository_FindAddOns_Call struct {
	*mock.Call
}

// FindAddOns is a helper method to define mock.On call
//   - addOns []add_onsentity.AddOn
func (_e *MockProgramRepository_Expecter) FindAddOns(addOns interface{}) *MockProgramRepository_FindAddOns_Call {
	return &MockProgramRepository_FindAddOns_Call{Call: _e.mock.On("FindAddOns", addOns)}
}

func (_c *MockProgramRepository_FindAddOns_Call) Run(run func(addOns []add_onsentity.AddOn)) *MockProgramRepository_FindAddOns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]add_onsentity.AddOn))
	})
	return _c
}

func (_c *MockProgramRepository_FindAddOns_Call) Return(_a0 []add_onsentity.AddOn, _a1 error) *MockProgramRepository_FindAddOns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_FindAddOns_Call) RunAndReturn(run func([]add_onsentity.AddOn) ([]add_onsentity.AddOn, error)) *MockProgramRepository_FindAddOns_Call {
	_c.Call.Return(run)
	return _c
}

// FindAll provides a mock function with given fields: locale
func (_m *MockProgramRepository) FindAll(locale string) ([]entity.Program, error) {
	ret := _m.Called(locale)

	if len(ret) == 0 {
		panic("no return value specified for FindAll")
	}

	var r0 []entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]entity.Program, error)); ok {
		return rf(locale)
	}
	if rf, ok := ret.Get(0).(func(string) []entity.Program); ok {
		r0 = rf(locale)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Program)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_FindAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAll'
type MockProgramRepository_FindAll_Call struct {
	*mock.Call
}

// FindAll is a helper method to define mock.On call
//   - locale string
func (_e *MockProgramRepository_Expecter) FindAll(locale interface{}) *MockProgramRepository_FindAll_Call {
	return &MockProgramRepository_FindAll_Call{Call: _e.mock.On("FindAll", locale)}
}

func (_c *MockProgramRepository_FindAll_Call) Run(run func(locale string)) *MockProgramRepository_FindAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockProgramRepository_FindAll_Call) Return(_a0 []entity.Program, _a1 error) *MockProgramRepository_FindAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_FindAll_Call) RunAndReturn(run func(string) ([]entity.Program, error)) *MockProgramRepository_FindAll_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function with given fields: id, locale
func (_m *MockProgramRepository) FindByID(id uint, locale string) (entity.Program, error) {
	ret := _m.Called(id, locale)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(uint, string) (entity.Program, error)); ok {
		return rf(id, locale)
	}
	if rf, ok := ret.Get(0).(func(uint, string) entity.Program); ok {
		r0 = rf(id, locale)
	} else {
		r0 = ret.Get(0).(entity.Program)
	}

	if rf, ok := ret.Get(1).(func(uint, string) error); ok {
		r1 = rf(id, locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockProgramRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - id uint
//   - locale string
func (_e *MockProgramRepository_Expecter) FindByID(id interface{}, locale interface{}) *MockProgramRepository_FindByID_Call {
	return &MockProgramRepository_FindByID_Call{Call: _e.mock.On("FindByID", id, locale)}
}

func (_c *MockProgramRepository_FindByID_Call) Run(run func(id uint, locale string)) *MockProgramRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint), args[1].(string))
	})
	return _c
}

func (_c *MockProgramRepository_FindByID_Call) Return(_a0 entity.Program, _a1 error) *MockProgramRepository_FindByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_FindByID_Call) RunAndReturn(run func(uint, string) (entity.Program, error)) *MockProgramRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindOneByID provides a mock function with given fields: ctx, id, locale
func (_m *MockProgramRepository) FindOneByID(ctx context.Context, id uint, locale string) (entity.Program, error) {
	ret := _m.Called(ctx, id, locale)

	if len(ret) == 0 {
		panic("no return value specified for FindOneByID")
	}

	var r0 entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) (entity.Program, error)); ok {
		return rf(ctx, id, locale)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint, string) entity.Program); ok {
		r0 = rf(ctx, id, locale)
	} else {
		r0 = ret.Get(0).(entity.Program)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint, string) error); ok {
		r1 = rf(ctx, id, locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_FindOneByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOneByID'
type MockProgramRepository_FindOneByID_Call struct {
	*mock.Call
}

// FindOneByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
//   - locale string
func (_e *MockProgramRepository_Expecter) FindOneByID(ctx interface{}, id interface{}, locale interface{}) *MockProgramRepository_FindOneByID_Call {
	return &MockProgramRepository_FindOneByID_Call{Call: _e.mock.On("FindOneByID", ctx, id, locale)}
}

func (_c *MockProgramRepository_FindOneByID_Call) Run(run func(ctx context.Context, id uint, locale string)) *MockProgramRepository_FindOneByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint), args[2].(string))
	})
	return _c
}

func (_c *MockProgramRepository_FindOneByID_Call) Return(_a0 entity.Program, _a1 error) *MockProgramRepository_FindOneByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_FindOneByID_Call) RunAndReturn(run func(context.Context, uint, string) (entity.Program, error)) *MockProgramRepository_FindOneByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindPartners provides a mock function with given fields: partners
func (_m *MockProgramRepository) FindPartners(partners []partnersentity.Partner) ([]partnersentity.Partner, error) {
	ret := _m.Called(partners)

	if len(ret) == 0 {
		panic("no return value specified for FindPartners")
	}

	var r0 []partnersentity.Partner
	var r1 error
	if rf, ok := ret.Get(0).(func([]partnersentity.Partner) ([]partnersentity.Partner, error)); ok {
		return rf(partners)
	}
	if rf, ok := ret.Get(0).(func([]partnersentity.Partner) []partnersentity.Partner); ok {
		r0 = rf(partners)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]partnersentity.Partner)
		}
	}

	if rf, ok := ret.Get(1).(func([]partnersentity.Partner) error); ok {
		r1 = rf(partners)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_FindPartners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindPartners'
type MockProgramRepository_FindPartners_Call struct {
	*mock.Call
}

// FindPartners is a helper method to define mock.On call
//   - partners []partnersentity.Partner
func (_e *MockProgramRepository_Expecter) FindPartners(partners interface{}) *MockProgramRepository_FindPartners_Call {
	return &MockProgramRepository_FindPartners_Call{Call: _e.mock.On("FindPartners", partners)}
}

func (_c *MockProgramRepository_FindPartners_Call) Run(run func(partners []partnersentity.Partner)) *MockProgramRepository_FindPartners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]partnersentity.Partner))
	})
	return _c
}

func (_c *MockProgramRepository_FindPartners_Call) Return(_a0 []partnersentity.Partner, _a1 error) *MockProgramRepository_FindPartners_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_FindPartners_Call) RunAndReturn(run func([]partnersentity.Partner) ([]partnersentity.Partner, error)) *MockProgramRepository_FindPartners_Call {
	_c.Call.Return(run)
	return _c
}

// PageContent provides a mock function with given fields: id, locale
func (_m *MockProgramRepository) PageContent(id uint, locale string) (model.ProgramPageContent, error) {
	ret := _m.Called(id, locale)

	if len(ret) == 0 {
		panic("no return value specified for PageContent")
	}

	var r0 model.ProgramPageContent
	var r1 error
	if rf, ok := ret.Get(0).(func(uint, string) (model.ProgramPageContent, error)); ok {
		return rf(id, locale)
	}
	if rf, ok := ret.Get(0).(func(uint, string) model.ProgramPageContent); ok {
		r0 = rf(id, locale)
	} else {
		r0 = ret.Get(0).(model.ProgramPageContent)
	}

	if rf, ok := ret.Get(1).(func(uint, string) error); ok {
		r1 = rf(id, locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_PageContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PageContent'
type MockProgramRepository_PageContent_Call struct {
	*mock.Call
}

// PageContent is a helper method to define mock.On call
//   - id uint
//   - locale string
func (_e *MockProgramRepository_Expecter) PageContent(id interface{}, locale interface{}) *MockProgramRepository_PageContent_Call {
	return &MockProgramRepository_PageContent_Call{Call: _e.mock.On("PageContent", id, locale)}
}

func (_c *MockProgramRepository_PageContent_Call) Run(run func(id uint, locale string)) *MockProgramRepository_PageContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uint), args[1].(string))
	})
	return _c
}

func (_c *MockProgramRepository_PageContent_Call) Return(_a0 model.ProgramPageContent, _a1 error) *MockProgramRepository_PageContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_PageContent_Call) RunAndReturn(run func(uint, string) (model.ProgramPageContent, error)) *MockProgramRepository_PageContent_Call {
	_c.Call.Return(run)
	return _c
}

// PageListContent provides a mock function with given fields: locale
func (_m *MockProgramRepository) PageListContent(locale string) (model.ProgramPageListContent, error) {
	ret := _m.Called(locale)

	if len(ret) == 0 {
		panic("no return value specified for PageListContent")
	}

	var r0 model.ProgramPageListContent
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (model.ProgramPageListContent, error)); ok {
		return rf(locale)
	}
	if rf, ok := ret.Get(0).(func(string) model.ProgramPageListContent); ok {
		r0 = rf(locale)
	} else {
		r0 = ret.Get(0).(model.ProgramPageListContent)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_PageListContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PageListContent'
type MockProgramRepository_PageListContent_Call struct {
	*mock.Call
}

// PageListContent is a helper method to define mock.On call
//   - locale string
func (_e *MockProgramRepository_Expecter) PageListContent(locale interface{}) *MockProgramRepository_PageListContent_Call {
	return &MockProgramRepository_PageListContent_Call{Call: _e.mock.On("PageListContent", locale)}
}

func (_c *MockProgramRepository_PageListContent_Call) Run(run func(locale string)) *MockProgramRepository_PageListContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockProgramRepository_PageListContent_Call) Return(_a0 model.ProgramPageListContent, _a1 error) *MockProgramRepository_PageListContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_PageListContent_Call) RunAndReturn(run func(string) (model.ProgramPageListContent, error)) *MockProgramRepository_PageListContent_Call {
	_c.Call.Return(run)
	return _c
}

// PageTagContent provides a mock function with given fields: locale, tag
func (_m *MockProgramRepository) PageTagContent(locale string, tag string) (model.ProgramPageTagContent, error) {
	ret := _m.Called(locale, tag)

	if len(ret) == 0 {
		panic("no return value specified for PageTagContent")
	}

	var r0 model.ProgramPageTagContent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (model.ProgramPageTagContent, error)); ok {
		return rf(locale, tag)
	}
	if rf, ok := ret.Get(0).(func(string, string) model.ProgramPageTagContent); ok {
		r0 = rf(locale, tag)
	} else {
		r0 = ret.Get(0).(model.ProgramPageTagContent)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(locale, tag)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_PageTagContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PageTagContent'
type MockProgramRepository_PageTagContent_Call struct {
	*mock.Call
}

// PageTagContent is a helper method to define mock.On call
//   - locale string
//   - tag string
func (_e *MockProgramRepository_Expecter) PageTagContent(locale interface{}, tag interface{}) *MockProgramRepository_PageTagContent_Call {
	return &MockProgramRepository_PageTagContent_Call{Call: _e.mock.On("PageTagContent", locale, tag)}
}

func (_c *MockProgramRepository_PageTagContent_Call) Run(run func(locale string, tag string)) *MockProgramRepository_PageTagContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockProgramRepository_PageTagContent_Call) Return(_a0 model.ProgramPageTagContent, _a1 error) *MockProgramRepository_PageTagContent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_PageTagContent_Call) RunAndReturn(run func(string, string) (model.ProgramPageTagContent, error)) *MockProgramRepository_PageTagContent_Call {
	_c.Call.Return(run)
	return _c
}

// SaveOrUpdate provides a mock function with given fields: program, programTranslation, locale
func (_m *MockProgramRepository) SaveOrUpdate(program entity.Program, programTranslation entity.ProgramTranslation, locale string) (entity.Program, error) {
	ret := _m.Called(program, programTranslation, locale)

	if len(ret) == 0 {
		panic("no return value specified for SaveOrUpdate")
	}

	var r0 entity.Program
	var r1 error
	if rf, ok := ret.Get(0).(func(entity.Program, entity.ProgramTranslation, string) (entity.Program, error)); ok {
		return rf(program, programTranslation, locale)
	}
	if rf, ok := ret.Get(0).(func(entity.Program, entity.ProgramTranslation, string) entity.Program); ok {
		r0 = rf(program, programTranslation, locale)
	} else {
		r0 = ret.Get(0).(entity.Program)
	}

	if rf, ok := ret.Get(1).(func(entity.Program, entity.ProgramTranslation, string) error); ok {
		r1 = rf(program, programTranslation, locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockProgramRepository_SaveOrUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveOrUpdate'
type MockProgramRepository_SaveOrUpdate_Call struct {
	*mock.Call
}

// SaveOrUpdate is a helper method to define mock.On call
//   - program entity.Program
//   - programTranslation entity.ProgramTranslation
//   - locale string
func (_e *MockProgramRepository_Expecter) SaveOrUpdate(program interface{}, programTranslation interface{}, locale interface{}) *MockProgramRepository_SaveOrUpdate_Call {
	return &MockProgramRepository_SaveOrUpdate_Call{Call: _e.mock.On("SaveOrUpdate", program, programTranslation, locale)}
}

func (_c *MockProgramRepository_SaveOrUpdate_Call) Run(run func(program entity.Program, programTranslation entity.ProgramTranslation, locale string)) *MockProgramRepository_SaveOrUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(entity.Program), args[1].(entity.ProgramTranslation), args[2].(string))
	})
	return _c
}

func (_c *MockProgramRepository_SaveOrUpdate_Call) Return(_a0 entity.Program, _a1 error) *MockProgramRepository_SaveOrUpdate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockProgramRepository_SaveOrUpdate_Call) RunAndReturn(run func(entity.Program, entity.ProgramTranslation, string) (entity.Program, error)) *MockProgramRepository_SaveOrUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProgramRepository creates a new instance of MockProgramRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProgramRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProgramRepository {
	mock := &MockProgramRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
