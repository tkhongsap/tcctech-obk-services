// Code generated by mockery v2.46.3. DO NOT EDIT.

package mocks

import (
	context "context"

	entity "example.com/art-culture-api/domain/booking/entity"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockBookingTxRepository is an autogenerated mock type for the BookingTxRepository type
type MockBookingTxRepository struct {
	mock.Mock
}

type MockBookingTxRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBookingTxRepository) EXPECT() *MockBookingTxRepository_Expecter {
	return &MockBookingTxRepository_Expecter{mock: &_m.Mock}
}

// CountByBookingSettingIDs provides a mock function with given fields: ctx, bookingSettingIDs
func (_m *MockBookingTxRepository) CountByBookingSettingIDs(ctx context.Context, bookingSettingIDs []string) (int64, error) {
	ret := _m.Called(ctx, bookingSettingIDs)

	if len(ret) == 0 {
		panic("no return value specified for CountByBookingSettingIDs")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int64, error)); ok {
		return rf(ctx, bookingSettingIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int64); ok {
		r0 = rf(ctx, bookingSettingIDs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, bookingSettingIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_CountByBookingSettingIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByBookingSettingIDs'
type MockBookingTxRepository_CountByBookingSettingIDs_Call struct {
	*mock.Call
}

// CountByBookingSettingIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - bookingSettingIDs []string
func (_e *MockBookingTxRepository_Expecter) CountByBookingSettingIDs(ctx interface{}, bookingSettingIDs interface{}) *MockBookingTxRepository_CountByBookingSettingIDs_Call {
	return &MockBookingTxRepository_CountByBookingSettingIDs_Call{Call: _e.mock.On("CountByBookingSettingIDs", ctx, bookingSettingIDs)}
}

func (_c *MockBookingTxRepository_CountByBookingSettingIDs_Call) Run(run func(ctx context.Context, bookingSettingIDs []string)) *MockBookingTxRepository_CountByBookingSettingIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSettingIDs_Call) Return(_a0 int64, _a1 error) *MockBookingTxRepository_CountByBookingSettingIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSettingIDs_Call) RunAndReturn(run func(context.Context, []string) (int64, error)) *MockBookingTxRepository_CountByBookingSettingIDs_Call {
	_c.Call.Return(run)
	return _c
}

// CountByBookingSlotDateIDs provides a mock function with given fields: ctx, bookingSlotDateIDs
func (_m *MockBookingTxRepository) CountByBookingSlotDateIDs(ctx context.Context, bookingSlotDateIDs []string) (int64, error) {
	ret := _m.Called(ctx, bookingSlotDateIDs)

	if len(ret) == 0 {
		panic("no return value specified for CountByBookingSlotDateIDs")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int64, error)); ok {
		return rf(ctx, bookingSlotDateIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int64); ok {
		r0 = rf(ctx, bookingSlotDateIDs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, bookingSlotDateIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_CountByBookingSlotDateIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByBookingSlotDateIDs'
type MockBookingTxRepository_CountByBookingSlotDateIDs_Call struct {
	*mock.Call
}

// CountByBookingSlotDateIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - bookingSlotDateIDs []string
func (_e *MockBookingTxRepository_Expecter) CountByBookingSlotDateIDs(ctx interface{}, bookingSlotDateIDs interface{}) *MockBookingTxRepository_CountByBookingSlotDateIDs_Call {
	return &MockBookingTxRepository_CountByBookingSlotDateIDs_Call{Call: _e.mock.On("CountByBookingSlotDateIDs", ctx, bookingSlotDateIDs)}
}

func (_c *MockBookingTxRepository_CountByBookingSlotDateIDs_Call) Run(run func(ctx context.Context, bookingSlotDateIDs []string)) *MockBookingTxRepository_CountByBookingSlotDateIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSlotDateIDs_Call) Return(_a0 int64, _a1 error) *MockBookingTxRepository_CountByBookingSlotDateIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSlotDateIDs_Call) RunAndReturn(run func(context.Context, []string) (int64, error)) *MockBookingTxRepository_CountByBookingSlotDateIDs_Call {
	_c.Call.Return(run)
	return _c
}

// CountByBookingSlotTimeIDs provides a mock function with given fields: ctx, bookingSlotTimeIDs
func (_m *MockBookingTxRepository) CountByBookingSlotTimeIDs(ctx context.Context, bookingSlotTimeIDs []string) (int64, error) {
	ret := _m.Called(ctx, bookingSlotTimeIDs)

	if len(ret) == 0 {
		panic("no return value specified for CountByBookingSlotTimeIDs")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (int64, error)); ok {
		return rf(ctx, bookingSlotTimeIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) int64); ok {
		r0 = rf(ctx, bookingSlotTimeIDs)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, bookingSlotTimeIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_CountByBookingSlotTimeIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountByBookingSlotTimeIDs'
type MockBookingTxRepository_CountByBookingSlotTimeIDs_Call struct {
	*mock.Call
}

// CountByBookingSlotTimeIDs is a helper method to define mock.On call
//   - ctx context.Context
//   - bookingSlotTimeIDs []string
func (_e *MockBookingTxRepository_Expecter) CountByBookingSlotTimeIDs(ctx interface{}, bookingSlotTimeIDs interface{}) *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call {
	return &MockBookingTxRepository_CountByBookingSlotTimeIDs_Call{Call: _e.mock.On("CountByBookingSlotTimeIDs", ctx, bookingSlotTimeIDs)}
}

func (_c *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call) Run(run func(ctx context.Context, bookingSlotTimeIDs []string)) *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call) Return(_a0 int64, _a1 error) *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call) RunAndReturn(run func(context.Context, []string) (int64, error)) *MockBookingTxRepository_CountByBookingSlotTimeIDs_Call {
	_c.Call.Return(run)
	return _c
}

// FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID provides a mock function with given fields: ctx, programID, bookerName, bookerEmail, bookingSlotTimeID
func (_m *MockBookingTxRepository) FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID(ctx context.Context, programID *uint, bookerName *string, bookerEmail *string, bookingSlotTimeID *string) ([]entity.BookingTx, error) {
	ret := _m.Called(ctx, programID, bookerName, bookerEmail, bookingSlotTimeID)

	if len(ret) == 0 {
		panic("no return value specified for FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID")
	}

	var r0 []entity.BookingTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *uint, *string, *string, *string) ([]entity.BookingTx, error)); ok {
		return rf(ctx, programID, bookerName, bookerEmail, bookingSlotTimeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *uint, *string, *string, *string) []entity.BookingTx); ok {
		r0 = rf(ctx, programID, bookerName, bookerEmail, bookingSlotTimeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.BookingTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *uint, *string, *string, *string) error); ok {
		r1 = rf(ctx, programID, bookerName, bookerEmail, bookingSlotTimeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID'
type MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call struct {
	*mock.Call
}

// FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID is a helper method to define mock.On call
//   - ctx context.Context
//   - programID *uint
//   - bookerName *string
//   - bookerEmail *string
//   - bookingSlotTimeID *string
func (_e *MockBookingTxRepository_Expecter) FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID(ctx interface{}, programID interface{}, bookerName interface{}, bookerEmail interface{}, bookingSlotTimeID interface{}) *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call {
	return &MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call{Call: _e.mock.On("FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID", ctx, programID, bookerName, bookerEmail, bookingSlotTimeID)}
}

func (_c *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call) Run(run func(ctx context.Context, programID *uint, bookerName *string, bookerEmail *string, bookingSlotTimeID *string)) *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*uint), args[2].(*string), args[3].(*string), args[4].(*string))
	})
	return _c
}

func (_c *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call) Return(_a0 []entity.BookingTx, _a1 error) *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call) RunAndReturn(run func(context.Context, *uint, *string, *string, *string) ([]entity.BookingTx, error)) *MockBookingTxRepository_FindAllByProgramIDOrBookerNameOrBookerEmailOrBookingSlotTimeID_Call {
	_c.Call.Return(run)
	return _c
}

// FindAllByUserID provides a mock function with given fields: ctx, locale, preloadFields, filterFields, _a4, userID
func (_m *MockBookingTxRepository) FindAllByUserID(ctx context.Context, locale string, preloadFields []string, filterFields map[string]any, _a4 time.Time, userID string) ([]entity.BookingTx, error) {
	ret := _m.Called(ctx, locale, preloadFields, filterFields, _a4, userID)

	if len(ret) == 0 {
		panic("no return value specified for FindAllByUserID")
	}

	var r0 []entity.BookingTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, map[string]any, time.Time, string) ([]entity.BookingTx, error)); ok {
		return rf(ctx, locale, preloadFields, filterFields, _a4, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, map[string]any, time.Time, string) []entity.BookingTx); ok {
		r0 = rf(ctx, locale, preloadFields, filterFields, _a4, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.BookingTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, map[string]any, time.Time, string) error); ok {
		r1 = rf(ctx, locale, preloadFields, filterFields, _a4, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_FindAllByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAllByUserID'
type MockBookingTxRepository_FindAllByUserID_Call struct {
	*mock.Call
}

// FindAllByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - locale string
//   - preloadFields []string
//   - filterFields map[string]any
//   - _a4 time.Time
//   - userID string
func (_e *MockBookingTxRepository_Expecter) FindAllByUserID(ctx interface{}, locale interface{}, preloadFields interface{}, filterFields interface{}, _a4 interface{}, userID interface{}) *MockBookingTxRepository_FindAllByUserID_Call {
	return &MockBookingTxRepository_FindAllByUserID_Call{Call: _e.mock.On("FindAllByUserID", ctx, locale, preloadFields, filterFields, _a4, userID)}
}

func (_c *MockBookingTxRepository_FindAllByUserID_Call) Run(run func(ctx context.Context, locale string, preloadFields []string, filterFields map[string]any, _a4 time.Time, userID string)) *MockBookingTxRepository_FindAllByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(map[string]any), args[4].(time.Time), args[5].(string))
	})
	return _c
}

func (_c *MockBookingTxRepository_FindAllByUserID_Call) Return(_a0 []entity.BookingTx, _a1 error) *MockBookingTxRepository_FindAllByUserID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_FindAllByUserID_Call) RunAndReturn(run func(context.Context, string, []string, map[string]any, time.Time, string) ([]entity.BookingTx, error)) *MockBookingTxRepository_FindAllByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function with given fields: ctx, id, locale
func (_m *MockBookingTxRepository) FindByID(ctx context.Context, id string, locale string) (entity.BookingTx, error) {
	ret := _m.Called(ctx, id, locale)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 entity.BookingTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (entity.BookingTx, error)); ok {
		return rf(ctx, id, locale)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) entity.BookingTx); ok {
		r0 = rf(ctx, id, locale)
	} else {
		r0 = ret.Get(0).(entity.BookingTx)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, id, locale)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockBookingTxRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - locale string
func (_e *MockBookingTxRepository_Expecter) FindByID(ctx interface{}, id interface{}, locale interface{}) *MockBookingTxRepository_FindByID_Call {
	return &MockBookingTxRepository_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id, locale)}
}

func (_c *MockBookingTxRepository_FindByID_Call) Run(run func(ctx context.Context, id string, locale string)) *MockBookingTxRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockBookingTxRepository_FindByID_Call) Return(_a0 entity.BookingTx, _a1 error) *MockBookingTxRepository_FindByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_FindByID_Call) RunAndReturn(run func(context.Context, string, string) (entity.BookingTx, error)) *MockBookingTxRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: ctx, bookingTx
func (_m *MockBookingTxRepository) Insert(ctx context.Context, bookingTx entity.BookingTx) (entity.BookingTx, error) {
	ret := _m.Called(ctx, bookingTx)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 entity.BookingTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, entity.BookingTx) (entity.BookingTx, error)); ok {
		return rf(ctx, bookingTx)
	}
	if rf, ok := ret.Get(0).(func(context.Context, entity.BookingTx) entity.BookingTx); ok {
		r0 = rf(ctx, bookingTx)
	} else {
		r0 = ret.Get(0).(entity.BookingTx)
	}

	if rf, ok := ret.Get(1).(func(context.Context, entity.BookingTx) error); ok {
		r1 = rf(ctx, bookingTx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBookingTxRepository_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockBookingTxRepository_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - bookingTx entity.BookingTx
func (_e *MockBookingTxRepository_Expecter) Insert(ctx interface{}, bookingTx interface{}) *MockBookingTxRepository_Insert_Call {
	return &MockBookingTxRepository_Insert_Call{Call: _e.mock.On("Insert", ctx, bookingTx)}
}

func (_c *MockBookingTxRepository_Insert_Call) Run(run func(ctx context.Context, bookingTx entity.BookingTx)) *MockBookingTxRepository_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(entity.BookingTx))
	})
	return _c
}

func (_c *MockBookingTxRepository_Insert_Call) Return(_a0 entity.BookingTx, _a1 error) *MockBookingTxRepository_Insert_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBookingTxRepository_Insert_Call) RunAndReturn(run func(context.Context, entity.BookingTx) (entity.BookingTx, error)) *MockBookingTxRepository_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBookingTxRepository creates a new instance of MockBookingTxRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBookingTxRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBookingTxRepository {
	mock := &MockBookingTxRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
